TraitResolution.dfy(65,22): Error: the type of in-parameter 'x' is different from the type of the same in-parameter in the corresponding method in the module it overrides ('int' instead of '(Y, B)')
TraitResolution.dfy(89,11): Error: new can be applied only to class types (got A?)
TraitResolution.dfy(90,11): Error: new can be applied only to class types (got ASynonym)
TraitResolution.dfy(93,11): Error: new can be applied only to class types (got B?)
TraitResolution.dfy(93,11): Error: when allocating an object of type 'B', one of its constructor methods must be called
TraitResolution.dfy(96,11): Error: new can be applied only to class types (got C?<A>)
TraitResolution.dfy(98,11): Error: new can be applied only to class types (got C?<A?>)
TraitResolution.dfy(101,11): Error: new can be applied only to class types (got D?<A>)
TraitResolution.dfy(101,11): Error: when allocating an object of type 'D', one of its constructor methods must be called
TraitResolution.dfy(103,11): Error: new can be applied only to class types (got D?<A?>)
TraitResolution.dfy(103,11): Error: when allocating an object of type 'D', one of its constructor methods must be called
TraitResolution.dfy(105,11): Error: new can be applied only to class types (got D<A>)
TraitResolution.dfy(105,11): Error: when allocating an object of type 'D', one of its constructor methods must be called
TraitResolution.dfy(107,11): Error: new can be applied only to class types (got D<A?>)
TraitResolution.dfy(107,11): Error: when allocating an object of type 'D', one of its constructor methods must be called
TraitResolution.dfy(108,11): Error: new can be applied only to class types (got DSynonym<A?>)
TraitResolution.dfy(108,11): Error: when allocating an object of type 'D', one of its constructor methods must be called
TraitResolution.dfy(109,11): Error: new can be applied only to class types (got DSynonym<A?>)
TraitResolution.dfy(109,11): Error: when allocating an object of type 'D', one of its constructor methods must be called
TraitResolution.dfy(112,11): Error: new can be applied only to class types (got object?)
TraitResolution.dfy(113,11): Error: new can be applied only to class types (got ObjectSynonym)
TraitResolution.dfy(114,11): Error: new can be applied only to class types (got ObjectWithConstraint)
TraitResolution.dfy(117,13): Error: new can be applied only to class types (got array?<int>)
TraitResolution.dfy(119,11): Error: new can be applied only to class types (got int)
TraitResolution.dfy(121,11): Error: new can be applied only to class types (got Tr<int>)
TraitResolution.dfy(122,11): Error: new can be applied only to class types (got Tr?<int>)
TraitResolution.dfy(123,11): Error: new can be applied only to class types (got Tr<int>)
TraitResolution.dfy(124,11): Error: new can be applied only to class types (got Tr<int>)
TraitResolution.dfy(129,16): Error: member name 'data' in class 'P' inherited from both traits 'A' and 'B'
TraitResolution.dfy(139,27): Error: duplicate trait parents with the same head type must also have the same type arguments (got C<Even> and C<int>)
TraitResolution.dfy(140,42): Error: duplicate trait parents with the same head type must also have the same type arguments (got C<int> and C<real>)
TraitResolution.dfy(140,59): Error: duplicate trait parents with the same head type must also have the same type arguments (got C<int> and C<Even>)
TraitResolution.dfy(148,8): Error: member name 'data' in class 'P' inherited from both traits 'B' and 'A'
TraitResolution.dfy(151,8): Error: member name 'data' in class 'Q' inherited from both traits 'C' and 'A'
TraitResolution.dfy(154,13): Error: member name 'data' in class 'R' inherited from both traits 'D' and 'A'
// TraitResolution.dfy

/*
module _System {
  /* CALL GRAPH for module _System:
   * SCC at height 2:
   *   RotateRight
   * SCC at height 1:
   *   RotateLeft
   * SCC at height 0:
   *   nat
   */
  type string(==) = seq<char>

  type {:axiom} nat(==) = x: int
    | 0 <= x

  trait {:compile false} object { }
  /*-- non-null type
  type {:axiom} object(==) = c: object? | c != null /*special witness*/
  */

  class {:compile false} array<arg> {
    var Length: int  // immutable
  }
  /*-- non-null type
  type {:axiom} array(==)<arg> = c: array?<arg> | c != null /*special witness*/
  */

  class {:compile false} /*_#Func1*/ -T0 ~> +R {
    function requires(x0: T0): bool
      reads reads(x0)

    function reads(x0: T0): set<object?>
      reads reads(x0)
  }

  type {:compile false} /*_#PartialFunc1*/ -T0 --> +R = f: T0 ~> R
    | forall x0: T0 :: f.reads(x0) == {}
    /*special witness*/

  type {:compile false} /*_#TotalFunc1*/ -T0 -> +R = f: T0 --> R
    | forall x0: T0 :: f.requires(x0)
    /*special witness*/

  class {:compile false} /*_#Func0*/ () ~> +R {
    function requires(): bool
      reads reads()

    function reads(): set<object?>
      reads reads()
  }

  type {:compile false} /*_#PartialFunc0*/ () --> +R = f: () ~> R
    | f.reads() == {}
    /*special witness*/

  type {:compile false} /*_#TotalFunc0*/ () -> +R = f: () --> R
    | f.requires()
    /*special witness*/

  datatype {:compile false} /*_tuple#2*/ (+T0, +T1) = _#Make2(0: T0, 1: T1)

  class {:compile false} /*_#Func2*/ (-T0, -T1) ~> +R {
    function requires(x0: T0, x1: T1): bool
      reads reads(x0, x1)

    function reads(x0: T0, x1: T1): set<object?>
      reads reads(x0, x1)
  }

  type {:compile false} /*_#PartialFunc2*/ (-T0, -T1) --> +R = f: (T0, T1) ~> R
    | forall x0: T0, x1: T1 :: f.reads(x0, x1) == {}
    /*special witness*/

  type {:compile false} /*_#TotalFunc2*/ (-T0, -T1) -> +R = f: (T0, T1) --> R
    | forall x0: T0, x1: T1 :: f.requires(x0, x1)
    /*special witness*/

  type bool { }

  type int { }

  type real {
    var Floor: int  // immutable
  }

  type ORDINAL {
    var IsLimit: bool  // immutable
    var IsSucc: bool  // immutable
    var Offset: int  // immutable
    var IsNat: bool  // immutable
  }

  type _bv {
    function method RotateLeft(w: nat): selftype

    function method RotateRight(w: nat): selftype
  }

  type map<T, U> {
    var Keys: set<T>  // immutable
    var Values: set<U>  // immutable
    var Items: set<(T, U)>  // immutable
  }

  type imap<T, U> {
    var Keys: iset<T>  // immutable
    var Values: iset<U>  // immutable
    var Items: iset<(T, U)>  // immutable
  }

  datatype /*_tuple#0*/ () = _#Make0
}
// bitvector types in use: bv10
*/

/* CALL GRAPH for module _module:
 */

module M0 {
  /* CALL GRAPH for module M0:
   * SCC at height 2:
   *   Cl.M
   * SCC at height 1:
   *   Tr.F
   * SCC at height 0:
   *   Tr
   */
  trait Tr<X> {
    function F(x: X): int
    {
      15
    }
  }
  /*-- non-null type
  type {:axiom} Tr(==)<X> = c: Tr?<X> | c != null /*special witness*/
  */

  class Cl<Y> extends Tr<Y> {
    lemma M()
    {
      ghost var v: Cl<Y> := this;
      ghost var u: Tr<Y> := this;
      ghost var f: Y -> int := v.F;
      ghost var g: Y -> int := this.F;
    }
  }
  /*-- non-null type
  type {:axiom} Cl(==)<Y> = c: Cl?<Y> | c != null /*special witness*/
  */
}

module M1 {
  /* CALL GRAPH for module M1:
   * SCC at height 1:
   *   M
   * SCC at height 0:
   *   Cl
   */
  trait Tr<X(0)> {
    var w: X
  }
  /*-- non-null type
  type {:axiom} Tr(==)<X(0)> = c: Tr?<X> | c != null /*special witness*/
  */

  class Cl<Y> extends Tr<(Y, Y)> { }
  /*-- non-null type
  type {:axiom} Cl(==)<Y> = c: Cl?<Y> | c != null /*special witness*/
  */

  lemma M(c: Cl<int>)
  {
    ghost var x: (int, int) := c.w;
  }
}

module M2 {
  /* CALL GRAPH for module M2:
   * SCC at height 2:
   *   M
   * SCC at height 1:
   *   Tr.F
   * SCC at height 0:
   *   Cl
   */
  trait Tr<X, W> {
    function method F(x: X, w: W): bv10
    {
      15
    }
  }
  /*-- non-null type
  type {:axiom} Tr(==)<X, W> = c: Tr?<X, W> | c != null /*special witness*/
  */

  class Cl<Y> extends Tr<(Y, Y), real> { }
  /*-- non-null type
  type {:axiom} Cl(==)<Y> = c: Cl?<Y> | c != null /*special witness*/
  */

  lemma M(c: Cl<int>)
  {
    ghost var aa: (int, int);
    ghost var bb: real;
    ghost var u: bv10 := c.F(aa, bb);
  }
}

module M3 {
  /* CALL GRAPH for module M3:
   * SCC at height 1:
   *   Cl.H
   * SCC at height 0:
   *   Tr.F
   */
  trait Tr<X, W> {
    function method F(x: X, w: W): bv10
    {
      15
    }
  }
  /*-- non-null type
  type {:axiom} Tr(==)<X, W> = c: Tr?<X, W> | c != null /*special witness*/
  */

  class Cl<Y> extends Tr<(Y, Y), real> {
    function method H(y: Y): bv10
    {
      F((y, y), 5.0)
    }
  }
  /*-- non-null type
  type {:axiom} Cl(==)<Y> = c: Cl?<Y> | c != null /*special witness*/
  */
}

module M4 {
  /* CALL GRAPH for module M4:
   * SCC at height 2:
   *   Tr.M
   * SCC at height 1:
   *   Cl.M
   * SCC at height 0:
   *   _tuple#2
   */
  trait Tr<X> {
    method M<A>(a: A, x: (X, A))
  }
  /*-- non-null type
  type {:axiom} Tr(==)<X> = c: Tr?<X> | c != null /*special witness*/
  */

  class Cl<Y> extends Tr<Y> {
    method M<B>(a: B, x: int)
    {
    }
  }
  /*-- non-null type
  type {:axiom} Cl(==)<Y> = c: Cl?<Y> | c != null /*special witness*/
  */
}

module NewMustMentionAClassName {
  /* CALL GRAPH for module NewMustMentionAClassName:
   * SCC at height 15:
   *   M
   * SCC at height 14:
   *   Tr
   * SCC at height 13:
   *   array
   * SCC at height 12:
   *   D.Init
   * SCC at height 11:
   *   D._ctor
   * SCC at height 10:
   *   C
   * SCC at height 9:
   *   B._ctor
   * SCC at height 8:
   *   B
   * SCC at height 7:
   *   ObjectWithConstraint
   * SCC at height 6:
   *   ObjectSynonym
   * SCC at height 5:
   *   object
   * SCC at height 4:
   *   DSynonym
   * SCC at height 3:
   *   D
   * SCC at height 2:
   *   _tuple#2
   * SCC at height 1:
   *   ASynonym
   * SCC at height 0:
   *   A
   */
  trait Tr<X> {
    method Make()
    {
    }
  }
  /*-- non-null type
  type {:axiom} Tr(==)<X> = c: Tr?<X> | c != null /*special witness*/
  */

  class A extends Tr<int> { }
  /*-- non-null type
  type {:axiom} A(==) = c: A? | c != null /*special witness*/
  */

  class B extends Tr<int> {
    constructor ()
    {
    }
  }
  /*-- non-null type
  type {:axiom} B(==) = c: B? | c != null /*special witness*/
  */

  class C<G> extends Tr<G> { }
  /*-- non-null type
  type {:axiom} C(==)<G> = c: C?<G> | c != null /*special witness*/
  */

  class D<G> extends Tr<G> {
    constructor ()
    {
    }

    constructor Init()
    {
    }
  }
  /*-- non-null type
  type {:axiom} D(==)<G> = c: D?<G> | c != null /*special witness*/
  */

  type ASynonym = A

  type DSynonym<H> = D<(H, int)>

  type ObjectSynonym = object

  type ObjectWithConstraint = o: object
    | true

  method M()
  {
    var a0: A := new A;
    var a1 := new A?;
    var a2 := new ASynonym;
    var b0: B := new B();
    var b1 := new B?();
    var c0: C<A> := new C<A>;
    var c1 := new C?<A>;
    var c2: C<A?> := new C<A?>;
    var c3 := new C?<A?>;
    var d0: D<A> := new D<A>();
    var d1 := new D?<A>();
    var d2: D<A?> := new D<A?>();
    var d3 := new D?<A?>();
    var d4: D<A> := new D<A>.Init();
    var d5 := new D?<A>.Init();
    var d6: D<A?> := new D<A?>.Init();
    var d7 := new D?<A?>.Init();
    var d8 := new DSynonym<A?>();
    var d9 := new DSynonym<A?>.Init();
    var o0: object := new object;
    var o1 := new object?;
    var o2 := new ObjectSynonym;
    var o3 := new ObjectWithConstraint;
    var arr0: array<int> := new array<int>;
    var arr1 := new array?<int>;
    var i0 := new int;
    var t0 := new Tr<int>;
    var t1 := new Tr?<int>;
    var t2 := new Tr<int>.Make();
    var t3 := new Tr?<int>.Make();
  }
}

module DuplicateParents {
  /* CALL GRAPH for module DuplicateParents:
   */
  trait A {
    var data: int
  }
  /*-- non-null type
  type {:axiom} A(==) = c: A? | c != null /*special witness*/
  */

  trait B {
    var data: int
  }
  /*-- non-null type
  type {:axiom} B(==) = c: B? | c != null /*special witness*/
  */

  trait C<X> { }
  /*-- non-null type
  type {:axiom} C(==)<X> = c: C?<X> | c != null /*special witness*/
  */

  type IntSynonym = int

  type Even = x: ?
    | x % 2 == 0

  class P extends A, A, B, A { }
  /*-- non-null type
  type {:axiom} P(==) = c: P? | c != null /*special witness*/
  */

  class Q extends C<int>, C<int> { }
  /*-- non-null type
  type {:axiom} Q(==) = c: Q? | c != null /*special witness*/
  */

  class R extends C<IntSynonym>, C<int> { }
  /*-- non-null type
  type {:axiom} R(==) = c: R? | c != null /*special witness*/
  */

  class S extends C<Even>, C<int> { }
  /*-- non-null type
  type {:axiom} S(==) = c: S? | c != null /*special witness*/
  */

  class T extends C<int>, C<int>, C<int>, C<real>, C<int>, C<Even> { }
  /*-- non-null type
  type {:axiom} T(==) = c: T? | c != null /*special witness*/
  */
}

module DuplicateInheritedMembers {
  /* CALL GRAPH for module DuplicateInheritedMembers:
   */
  trait A {
    var data: int
  }
  /*-- non-null type
  type {:axiom} A(==) = c: A? | c != null /*special witness*/
  */

  trait B {
    var data: int
  }
  /*-- non-null type
  type {:axiom} B(==) = c: B? | c != null /*special witness*/
  */

  trait C {
    var data: real
  }
  /*-- non-null type
  type {:axiom} C(==) = c: C? | c != null /*special witness*/
  */

  trait D {
    function data(): int
    {
      5
    }
  }
  /*-- non-null type
  type {:axiom} D(==) = c: D? | c != null /*special witness*/
  */

  class P extends B, A { }
  /*-- non-null type
  type {:axiom} P(==) = c: P? | c != null /*special witness*/
  */

  class Q extends C, A { }
  /*-- non-null type
  type {:axiom} Q(==) = c: Q? | c != null /*special witness*/
  */

  class R extends D, A { }
  /*-- non-null type
  type {:axiom} R(==) = c: R? | c != null /*special witness*/
  */
}
35 resolution/type errors detected in TraitResolution.dfy
